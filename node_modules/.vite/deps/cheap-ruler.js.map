{
  "version": 3,
  "sources": ["../../cheap-ruler/index.js"],
  "sourcesContent": ["\nconst factors = {\n    kilometers: 1,\n    miles: 1000 / 1609.344,\n    nauticalmiles: 1000 / 1852,\n    meters: 1000,\n    metres: 1000,\n    yards: 1000 / 0.9144,\n    feet: 1000 / 0.3048,\n    inches: 1000 / 0.0254\n};\n\n// Values that define WGS84 ellipsoid model of the Earth\nconst RE = 6378.137; // equatorial radius\nconst FE = 1 / 298.257223563; // flattening\n\nconst E2 = FE * (2 - FE);\nconst RAD = Math.PI / 180;\n\n/**\n * A collection of very fast approximations to common geodesic measurements. Useful for performance-sensitive code that measures things on a city scale.\n */\nexport default class CheapRuler {\n    /**\n     * Creates a ruler object from tile coordinates (y and z).\n     *\n     * @param {number} y\n     * @param {number} z\n     * @param {keyof typeof factors} [units='kilometers']\n     * @returns {CheapRuler}\n     * @example\n     * const ruler = cheapRuler.fromTile(1567, 12);\n     * //=ruler\n     */\n    static fromTile(y, z, units) {\n        const n = Math.PI * (1 - 2 * (y + 0.5) / Math.pow(2, z));\n        const lat = Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))) / RAD;\n        return new CheapRuler(lat, units);\n    }\n\n    /**\n     * Multipliers for converting between units.\n     *\n     * @example\n     * // convert 50 meters to yards\n     * 50 * CheapRuler.units.yards / CheapRuler.units.meters;\n     */\n    static get units() {\n        return factors;\n    }\n\n    /**\n     * Creates a ruler instance for very fast approximations to common geodesic measurements around a certain latitude.\n     *\n     * @param {number} lat latitude\n     * @param {keyof typeof factors} [units='kilometers']\n     * @example\n     * const ruler = cheapRuler(35.05, 'miles');\n     * //=ruler\n     */\n    constructor(lat, units) {\n        if (lat === undefined) throw new Error('No latitude given.');\n        if (units && !factors[units]) throw new Error(`Unknown unit ${  units  }. Use one of: ${  Object.keys(factors).join(', ')}`);\n\n        // Curvature formulas from https://en.wikipedia.org/wiki/Earth_radius#Meridional\n        const m = RAD * RE * (units ? factors[units] : 1);\n        const coslat = Math.cos(lat * RAD);\n        const w2 = 1 / (1 - E2 * (1 - coslat * coslat));\n        const w = Math.sqrt(w2);\n\n        // multipliers for converting longitude and latitude degrees into distance\n        this.kx = m * w * coslat;        // based on normal radius of curvature\n        this.ky = m * w * w2 * (1 - E2); // based on meridonal radius of curvature\n    }\n\n    /**\n     * Given two points of the form [longitude, latitude], returns the distance.\n     *\n     * @param {[number, number]} a point [longitude, latitude]\n     * @param {[number, number]} b point [longitude, latitude]\n     * @returns {number} distance\n     * @example\n     * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);\n     * //=distance\n     */\n    distance(a, b) {\n        const dx = wrap(a[0] - b[0]) * this.kx;\n        const dy = (a[1] - b[1]) * this.ky;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Returns the bearing between two points in angles.\n     *\n     * @param {[number, number]} a point [longitude, latitude]\n     * @param {[number, number]} b point [longitude, latitude]\n     * @returns {number} bearing\n     * @example\n     * const bearing = ruler.bearing([30.5, 50.5], [30.51, 50.49]);\n     * //=bearing\n     */\n    bearing(a, b) {\n        const dx = wrap(b[0] - a[0]) * this.kx;\n        const dy = (b[1] - a[1]) * this.ky;\n        return Math.atan2(dx, dy) / RAD;\n    }\n\n    /**\n     * Returns a new point given distance and bearing from the starting point.\n     *\n     * @param {[number, number]} p point [longitude, latitude]\n     * @param {number} dist distance\n     * @param {number} bearing\n     * @returns {[number, number]} point [longitude, latitude]\n     * @example\n     * const point = ruler.destination([30.5, 50.5], 0.1, 90);\n     * //=point\n     */\n    destination(p, dist, bearing) {\n        const a = bearing * RAD;\n        return this.offset(p,\n            Math.sin(a) * dist,\n            Math.cos(a) * dist);\n    }\n\n    /**\n     * Returns a new point given easting and northing offsets (in ruler units) from the starting point.\n     *\n     * @param {[number, number]} p point [longitude, latitude]\n     * @param {number} dx easting\n     * @param {number} dy northing\n     * @returns {[number, number]} point [longitude, latitude]\n     * @example\n     * const point = ruler.offset([30.5, 50.5], 10, 10);\n     * //=point\n     */\n    offset(p, dx, dy) {\n        return [\n            p[0] + dx / this.kx,\n            p[1] + dy / this.ky\n        ];\n    }\n\n    /**\n     * Given a line (an array of points), returns the total line distance.\n     *\n     * @param {[number, number][]} points [longitude, latitude]\n     * @returns {number} total line distance\n     * @example\n     * const length = ruler.lineDistance([\n     *     [-67.031, 50.458], [-67.031, 50.534],\n     *     [-66.929, 50.534], [-66.929, 50.458]\n     * ]);\n     * //=length\n     */\n    lineDistance(points) {\n        let total = 0;\n        for (let i = 0; i < points.length - 1; i++) {\n            total += this.distance(points[i], points[i + 1]);\n        }\n        return total;\n    }\n\n    /**\n     * Given a polygon (an array of rings, where each ring is an array of points), returns the area.\n     *\n     * @param {[number, number][][]} polygon\n     * @returns {number} area value in the specified units (square kilometers by default)\n     * @example\n     * const area = ruler.area([[\n     *     [-67.031, 50.458], [-67.031, 50.534], [-66.929, 50.534],\n     *     [-66.929, 50.458], [-67.031, 50.458]\n     * ]]);\n     * //=area\n     */\n    area(polygon) {\n        let sum = 0;\n\n        for (let i = 0; i < polygon.length; i++) {\n            const ring = polygon[i];\n\n            for (let j = 0, len = ring.length, k = len - 1; j < len; k = j++) {\n                sum += wrap(ring[j][0] - ring[k][0]) * (ring[j][1] + ring[k][1]) * (i ? -1 : 1);\n            }\n        }\n\n        return (Math.abs(sum) / 2) * this.kx * this.ky;\n    }\n\n    /**\n     * Returns the point at a specified distance along the line.\n     *\n     * @param {[number, number][]} line\n     * @param {number} dist distance\n     * @returns {[number, number]} point [longitude, latitude]\n     * @example\n     * const point = ruler.along(line, 2.5);\n     * //=point\n     */\n    along(line, dist) {\n        let sum = 0;\n\n        if (dist <= 0) return line[0];\n\n        for (let i = 0; i < line.length - 1; i++) {\n            const p0 = line[i];\n            const p1 = line[i + 1];\n            const d = this.distance(p0, p1);\n            sum += d;\n            if (sum > dist) return interpolate(p0, p1, (dist - (sum - d)) / d);\n        }\n\n        return line[line.length - 1];\n    }\n\n    /**\n     * Returns the distance from a point `p` to a line segment `a` to `b`.\n     *\n     * @pointToSegmentDistance\n     * @param {[number, number]} p point [longitude, latitude]\n     * @param {[number, number]} a segment point 1 [longitude, latitude]\n     * @param {[number, number]} b segment point 2 [longitude, latitude]\n     * @returns {number} distance\n     * @example\n     * const distance = ruler.pointToSegmentDistance([-67.04, 50.5], [-67.05, 50.57], [-67.03, 50.54]);\n     * //=distance\n     */\n    pointToSegmentDistance(p, a, b) {\n        let [x, y] = a;\n        let dx = wrap(b[0] - x) * this.kx;\n        let dy = (b[1] - y) * this.ky;\n\n        if (dx !== 0 || dy !== 0) {\n            const t = (wrap(p[0] - x) * this.kx * dx + (p[1] - y) * this.ky * dy) / (dx * dx + dy * dy);\n\n            if (t > 1) {\n                x = b[0];\n                y = b[1];\n\n            } else if (t > 0) {\n                x += (dx / this.kx) * t;\n                y += (dy / this.ky) * t;\n            }\n        }\n\n        dx = wrap(p[0] - x) * this.kx;\n        dy = (p[1] - y) * this.ky;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Returns an object of the form {point, index, t}, where point is closest point on the line\n     * from the given point, index is the start index of the segment with the closest point,\n     * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.\n     *\n     * @param {[number, number][]} line\n     * @param {[number, number]} p point [longitude, latitude]\n     * @returns {{point: [number, number], index: number, t: number}} {point, index, t}\n     * @example\n     * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;\n     * //=point\n     */\n    pointOnLine(line, p) {\n        let minDist = Infinity;\n        let minX = line[0][0];\n        let minY = line[0][1];\n        let minI = 0;\n        let minT = 0;\n\n        for (let i = 0; i < line.length - 1; i++) {\n\n            let x = line[i][0];\n            let y = line[i][1];\n            let dx = wrap(line[i + 1][0] - x) * this.kx;\n            let dy = (line[i + 1][1] - y) * this.ky;\n            let t = 0;\n\n            if (dx !== 0 || dy !== 0) {\n                t = (wrap(p[0] - x) * this.kx * dx + (p[1] - y) * this.ky * dy) / (dx * dx + dy * dy);\n\n                if (t > 1) {\n                    x = line[i + 1][0];\n                    y = line[i + 1][1];\n\n                } else if (t > 0) {\n                    x += (dx / this.kx) * t;\n                    y += (dy / this.ky) * t;\n                }\n            }\n\n            dx = wrap(p[0] - x) * this.kx;\n            dy = (p[1] - y) * this.ky;\n\n            const sqDist = dx * dx + dy * dy;\n            if (sqDist < minDist) {\n                minDist = sqDist;\n                minX = x;\n                minY = y;\n                minI = i;\n                minT = t;\n            }\n        }\n\n        return {\n            point: [minX, minY],\n            index: minI,\n            t: Math.max(0, Math.min(1, minT))\n        };\n    }\n\n    /**\n     * Returns a part of the given line between the start and the stop points (or their closest points on the line).\n     *\n     * @param {[number, number]} start point [longitude, latitude]\n     * @param {[number, number]} stop point [longitude, latitude]\n     * @param {[number, number][]} line\n     * @returns {[number, number][]} line part of a line\n     * @example\n     * const line2 = ruler.lineSlice([-67.04, 50.5], [-67.05, 50.56], line1);\n     * //=line2\n     */\n    lineSlice(start, stop, line) {\n        let p1 = this.pointOnLine(line, start);\n        let p2 = this.pointOnLine(line, stop);\n\n        if (p1.index > p2.index || (p1.index === p2.index && p1.t > p2.t)) {\n            const tmp = p1;\n            p1 = p2;\n            p2 = tmp;\n        }\n\n        const slice = [p1.point];\n\n        const l = p1.index + 1;\n        const r = p2.index;\n\n        if (!equals(line[l], slice[0]) && l <= r)\n            slice.push(line[l]);\n\n        for (let i = l + 1; i <= r; i++) {\n            slice.push(line[i]);\n        }\n\n        if (!equals(line[r], p2.point))\n            slice.push(p2.point);\n\n        return slice;\n    }\n\n    /**\n     * Returns a part of the given line between the start and the stop points indicated by distance along the line.\n     *\n     * @param {number} start start distance\n     * @param {number} stop stop distance\n     * @param {[number, number][]} line\n     * @returns {[number, number][]} part of a line\n     * @example\n     * const line2 = ruler.lineSliceAlong(10, 20, line1);\n     * //=line2\n     */\n    lineSliceAlong(start, stop, line) {\n        let sum = 0;\n        const slice = [];\n\n        for (let i = 0; i < line.length - 1; i++) {\n            const p0 = line[i];\n            const p1 = line[i + 1];\n            const d = this.distance(p0, p1);\n\n            sum += d;\n\n            if (sum > start && slice.length === 0) {\n                slice.push(interpolate(p0, p1, (start - (sum - d)) / d));\n            }\n\n            if (sum >= stop) {\n                slice.push(interpolate(p0, p1, (stop - (sum - d)) / d));\n                return slice;\n            }\n\n            if (sum > start) slice.push(p1);\n        }\n\n        return slice;\n    }\n\n    /**\n     * Given a point, returns a bounding box object ([w, s, e, n]) created from the given point buffered by a given distance.\n     *\n     * @param {[number, number]} p point [longitude, latitude]\n     * @param {number} buffer\n     * @returns {[number, number, number, number]} bbox ([w, s, e, n])\n     * @example\n     * const bbox = ruler.bufferPoint([30.5, 50.5], 0.01);\n     * //=bbox\n     */\n    bufferPoint(p, buffer) {\n        const v = buffer / this.ky;\n        const h = buffer / this.kx;\n        return [\n            p[0] - h,\n            p[1] - v,\n            p[0] + h,\n            p[1] + v\n        ];\n    }\n\n    /**\n     * Given a bounding box, returns the box buffered by a given distance.\n     *\n     * @param {[number, number, number, number]} bbox ([w, s, e, n])\n     * @param {number} buffer\n     * @returns {[number, number, number, number]} bbox ([w, s, e, n])\n     * @example\n     * const bbox = ruler.bufferBBox([30.5, 50.5, 31, 51], 0.2);\n     * //=bbox\n     */\n    bufferBBox(bbox, buffer) {\n        const v = buffer / this.ky;\n        const h = buffer / this.kx;\n        return [\n            bbox[0] - h,\n            bbox[1] - v,\n            bbox[2] + h,\n            bbox[3] + v\n        ];\n    }\n\n    /**\n     * Returns true if the given point is inside in the given bounding box, otherwise false.\n     *\n     * @param {[number, number]} p point [longitude, latitude]\n     * @param {[number, number, number, number]} bbox ([w, s, e, n])\n     * @returns {boolean}\n     * @example\n     * const inside = ruler.insideBBox([30.5, 50.5], [30, 50, 31, 51]);\n     * //=inside\n     */\n    insideBBox(p, bbox) { // eslint-disable-line\n        return wrap(p[0] - bbox[0]) >= 0 &&\n               wrap(p[0] - bbox[2]) <= 0 &&\n               p[1] >= bbox[1] &&\n               p[1] <= bbox[3];\n    }\n}\n\n/**\n * @param {[number, number]} a\n * @param {[number, number]} b\n */\nfunction equals(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * @param {[number, number]} a\n * @param {[number, number]} b\n * @param {number} t\n * @returns {[number, number]}\n */\nfunction interpolate(a, b, t) {\n    const dx = wrap(b[0] - a[0]);\n    const dy = b[1] - a[1];\n    return [\n        a[0] + dx * t,\n        a[1] + dy * t\n    ];\n}\n\n/**\n * normalize a degree value into [-180..180] range\n * @param {number} deg\n */\nfunction wrap(deg) {\n    while (deg < -180) deg += 360;\n    while (deg > 180) deg -= 360;\n    return deg;\n}\n"],
  "mappings": "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",
  "names": []
}
